// Generated by dts-bundle-generator v7.2.0

export interface FormValidationResult {
	isValid: boolean;
	inputElement: HTMLElement;
	message?: string;
}
export interface FormValidationFeedbackHandlers {
	onValid: (result: FormValidationResult) => void;
	onInvalid: (result: FormValidationResult) => void;
}
export interface InputRules {
	element: HTMLElement;
	rules: Array<Rule>;
}
export interface Rule {
	validatorName?: keyof RegexRules;
	customValidator?: (value: string) => boolean;
	invalidMessage: string;
}
export type RegexRules = {
	[key: string]: RegExp;
};
// TypeScript Version: 4.7
export type AxiosHeaderValue = AxiosHeaders | string | string[] | number | boolean | null;
export interface RawAxiosHeaders {
	[key: string]: AxiosHeaderValue;
}
export type MethodsHeaders = Partial<{
	[Key in Method as Lowercase<Key>]: AxiosHeaders;
} & {
	common: AxiosHeaders;
}>;
export type AxiosHeaderMatcher = (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean;
declare class AxiosHeaders {
	constructor(headers?: RawAxiosHeaders | AxiosHeaders);
	[key: string]: any;
	set(headerName?: string, value?: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	set(headers?: RawAxiosHeaders | AxiosHeaders, rewrite?: boolean): AxiosHeaders;
	get(headerName: string, parser: RegExp): RegExpExecArray | null;
	get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
	has(header: string, matcher?: true | AxiosHeaderMatcher): boolean;
	delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;
	clear(matcher?: AxiosHeaderMatcher): boolean;
	normalize(format: boolean): AxiosHeaders;
	concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
	toJSON(asStrings?: boolean): RawAxiosHeaders;
	static from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;
	static accessor(header: string | string[]): AxiosHeaders;
	static concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
	setContentType(value: ContentType, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getContentType(parser?: RegExp): RegExpExecArray | null;
	getContentType(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasContentType(matcher?: AxiosHeaderMatcher): boolean;
	setContentLength(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getContentLength(parser?: RegExp): RegExpExecArray | null;
	getContentLength(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasContentLength(matcher?: AxiosHeaderMatcher): boolean;
	setAccept(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getAccept(parser?: RegExp): RegExpExecArray | null;
	getAccept(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasAccept(matcher?: AxiosHeaderMatcher): boolean;
	setUserAgent(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getUserAgent(parser?: RegExp): RegExpExecArray | null;
	getUserAgent(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasUserAgent(matcher?: AxiosHeaderMatcher): boolean;
	setContentEncoding(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getContentEncoding(parser?: RegExp): RegExpExecArray | null;
	getContentEncoding(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasContentEncoding(matcher?: AxiosHeaderMatcher): boolean;
	setAuthorization(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;
	getAuthorization(parser?: RegExp): RegExpExecArray | null;
	getAuthorization(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;
	hasAuthorization(matcher?: AxiosHeaderMatcher): boolean;
	[Symbol.iterator](): IterableIterator<[
		string,
		AxiosHeaderValue
	]>;
}
export type CommonRequestHeadersList = "Accept" | "Content-Length" | "User-Agent" | "Content-Encoding" | "Authorization";
export type ContentType = AxiosHeaderValue | "text/html" | "text/plain" | "multipart/form-data" | "application/json" | "application/x-www-form-urlencoded" | "application/octet-stream";
export type RawAxiosRequestHeaders = Partial<RawAxiosHeaders & {
	[Key in CommonRequestHeadersList]: AxiosHeaderValue;
} & {
	"Content-Type": ContentType;
}>;
export type AxiosRequestHeaders = RawAxiosRequestHeaders & AxiosHeaders;
export type CommonResponseHeadersList = "Server" | "Content-Type" | "Content-Length" | "Cache-Control" | "Content-Encoding";
export type RawCommonResponseHeaders = {
	[Key in CommonResponseHeadersList]: AxiosHeaderValue;
} & {
	"set-cookie": string[];
};
export type RawAxiosResponseHeaders = Partial<RawAxiosHeaders & RawCommonResponseHeaders>;
export type AxiosResponseHeaders = RawAxiosResponseHeaders & AxiosHeaders;
export interface AxiosRequestTransformer {
	(this: InternalAxiosRequestConfig, data: any, headers: AxiosRequestHeaders): any;
}
export interface AxiosResponseTransformer {
	(this: InternalAxiosRequestConfig, data: any, headers: AxiosResponseHeaders, status?: number): any;
}
export interface AxiosAdapter {
	(config: InternalAxiosRequestConfig): AxiosPromise;
}
export interface AxiosBasicCredentials {
	username: string;
	password: string;
}
export interface AxiosProxyConfig {
	host: string;
	port: number;
	auth?: {
		username: string;
		password: string;
	};
	protocol?: string;
}
export type Method = "get" | "GET" | "delete" | "DELETE" | "head" | "HEAD" | "options" | "OPTIONS" | "post" | "POST" | "put" | "PUT" | "patch" | "PATCH" | "purge" | "PURGE" | "link" | "LINK" | "unlink" | "UNLINK";
export type ResponseType = "arraybuffer" | "blob" | "document" | "json" | "text" | "stream";
export type responseEncoding = "ascii" | "ASCII" | "ansi" | "ANSI" | "binary" | "BINARY" | "base64" | "BASE64" | "base64url" | "BASE64URL" | "hex" | "HEX" | "latin1" | "LATIN1" | "ucs-2" | "UCS-2" | "ucs2" | "UCS2" | "utf-8" | "UTF-8" | "utf8" | "UTF8" | "utf16le" | "UTF16LE";
export interface TransitionalOptions {
	silentJSONParsing?: boolean;
	forcedJSONParsing?: boolean;
	clarifyTimeoutError?: boolean;
}
export interface GenericAbortSignal {
	readonly aborted: boolean;
	onabort?: ((...args: any) => any) | null;
	addEventListener?: (...args: any) => any;
	removeEventListener?: (...args: any) => any;
}
export interface FormDataVisitorHelpers {
	defaultVisitor: SerializerVisitor;
	convertValue: (value: any) => any;
	isVisitable: (value: any) => boolean;
}
export interface SerializerVisitor {
	(this: GenericFormData, value: any, key: string | number, path: null | Array<string | number>, helpers: FormDataVisitorHelpers): boolean;
}
export interface SerializerOptions {
	visitor?: SerializerVisitor;
	dots?: boolean;
	metaTokens?: boolean;
	indexes?: boolean | null;
}
// tslint:disable-next-line
export interface FormSerializerOptions extends SerializerOptions {
}
export interface ParamEncoder {
	(value: any, defaultEncoder: (value: any) => any): any;
}
export interface CustomParamsSerializer {
	(params: Record<string, any>, options?: ParamsSerializerOptions): string;
}
export interface ParamsSerializerOptions extends SerializerOptions {
	encode?: ParamEncoder;
	serialize?: CustomParamsSerializer;
}
export type MaxUploadRate = number;
export type MaxDownloadRate = number;
export type BrowserProgressEvent = any;
export interface AxiosProgressEvent {
	loaded: number;
	total?: number;
	progress?: number;
	bytes: number;
	rate?: number;
	estimated?: number;
	upload?: boolean;
	download?: boolean;
	event?: BrowserProgressEvent;
}
export type Milliseconds = number;
export type AxiosAdapterName = "xhr" | "http" | string;
export type AxiosAdapterConfig = AxiosAdapter | AxiosAdapterName;
export interface AxiosRequestConfig<D = any> {
	url?: string;
	method?: Method | string;
	baseURL?: string;
	transformRequest?: AxiosRequestTransformer | AxiosRequestTransformer[];
	transformResponse?: AxiosResponseTransformer | AxiosResponseTransformer[];
	headers?: (RawAxiosRequestHeaders & MethodsHeaders) | AxiosHeaders;
	params?: any;
	paramsSerializer?: ParamsSerializerOptions;
	data?: D;
	timeout?: Milliseconds;
	timeoutErrorMessage?: string;
	withCredentials?: boolean;
	adapter?: AxiosAdapterConfig | AxiosAdapterConfig[];
	auth?: AxiosBasicCredentials;
	responseType?: ResponseType;
	responseEncoding?: responseEncoding | string;
	xsrfCookieName?: string;
	xsrfHeaderName?: string;
	onUploadProgress?: (progressEvent: AxiosProgressEvent) => void;
	onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void;
	maxContentLength?: number;
	validateStatus?: ((status: number) => boolean) | null;
	maxBodyLength?: number;
	maxRedirects?: number;
	maxRate?: number | [
		MaxUploadRate,
		MaxDownloadRate
	];
	beforeRedirect?: (options: Record<string, any>, responseDetails: {
		headers: Record<string, string>;
	}) => void;
	socketPath?: string | null;
	httpAgent?: any;
	httpsAgent?: any;
	proxy?: AxiosProxyConfig | false;
	cancelToken?: CancelToken;
	decompress?: boolean;
	transitional?: TransitionalOptions;
	signal?: GenericAbortSignal;
	insecureHTTPParser?: boolean;
	env?: {
		FormData?: new (...args: any[]) => object;
	};
	formSerializer?: FormSerializerOptions;
}
export interface InternalAxiosRequestConfig<D = any> extends AxiosRequestConfig<D> {
	headers: AxiosRequestHeaders;
}
export interface HeadersDefaults {
	common: RawAxiosRequestHeaders;
	delete: RawAxiosRequestHeaders;
	get: RawAxiosRequestHeaders;
	head: RawAxiosRequestHeaders;
	post: RawAxiosRequestHeaders;
	put: RawAxiosRequestHeaders;
	patch: RawAxiosRequestHeaders;
	options?: RawAxiosRequestHeaders;
	purge?: RawAxiosRequestHeaders;
	link?: RawAxiosRequestHeaders;
	unlink?: RawAxiosRequestHeaders;
}
export interface AxiosDefaults<D = any> extends Omit<AxiosRequestConfig<D>, "headers"> {
	headers: HeadersDefaults;
}
export interface AxiosResponse<T = any, D = any> {
	data: T;
	status: number;
	statusText: string;
	headers: RawAxiosResponseHeaders | AxiosResponseHeaders;
	config: InternalAxiosRequestConfig<D>;
	request?: any;
}
export type AxiosPromise<T = any> = Promise<AxiosResponse<T>>;
export interface Cancel {
	message: string | undefined;
}
export interface CancelToken {
	promise: Promise<Cancel>;
	reason?: Cancel;
	throwIfRequested(): void;
}
export interface AxiosInterceptorOptions {
	synchronous?: boolean;
	runWhen?: (config: InternalAxiosRequestConfig) => boolean;
}
export interface AxiosInterceptorManager<V> {
	use(onFulfilled?: ((value: V) => V | Promise<V>) | null, onRejected?: ((error: any) => any) | null, options?: AxiosInterceptorOptions): number;
	eject(id: number): void;
	clear(): void;
}
declare class Axios {
	constructor(config?: AxiosRequestConfig);
	defaults: AxiosDefaults;
	interceptors: {
		request: AxiosInterceptorManager<InternalAxiosRequestConfig>;
		response: AxiosInterceptorManager<AxiosResponse>;
	};
	getUri(config?: AxiosRequestConfig): string;
	request<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;
	get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
	delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
	head<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
	options<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
	post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
	put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
	patch<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
	postForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
	putForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
	patchForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;
}
export interface AxiosInstance extends Axios {
	<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;
	<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;
	defaults: Omit<AxiosDefaults, "headers"> & {
		headers: HeadersDefaults & {
			[key: string]: AxiosHeaderValue;
		};
	};
}
export interface GenericFormData {
	append(name: string, value: any, options?: any): any;
}
export interface ApiRequestFeedbackHandlers {
	onSuccess: (message: string) => void;
	onError: (message: string) => void;
	onInfo: (message: string) => void;
	onWarning: (message: string) => void;
	onUnAuthorized: (message: string) => void;
}
declare class ApiUtils {
	private readonly _instance;
	private readonly _feedbackHandlers;
	constructor(feedbackHandlers: ApiRequestFeedbackHandlers);
	get currentAxiosInstance(): AxiosInstance;
	newAxiosInstance(): AxiosInstance;
	setHeader(key: string, value: string): void;
	get(url: string, data?: any): Promise<AxiosResponse<any, any> | any>;
	post(url: string, data?: object): Promise<AxiosResponse<any, any> | any>;
	put(url: string, data?: object): Promise<AxiosResponse<any, any> | any>;
	del(url: string, data?: object): Promise<AxiosResponse<any, any> | any>;
	patch(url: string, data?: object): Promise<AxiosResponse<any, any> | any>;
	private responseInterceptorOnSuccess;
	private responseInterceptorOnError;
}
declare class Validation {
	private readonly _feedbackHandlers;
	private initialized;
	private _withAsync;
	private validateResult;
	private inputRules;
	constructor(feedbackHandlers: FormValidationFeedbackHandlers, withAsync?: boolean);
	init(inputRules: InputRules[]): Validation;
	withAsync(): Validation;
	noAsync(): Validation;
	validate(): Validation;
	getResult(): boolean;
	private handleValidateField;
}
declare class Dsync {
	private _data;
	constructor();
	set(key: string, value: string | number | object): void;
	get(key: string): string | number | object | undefined;
	remove(key: string): void;
	has(key: string): boolean;
}
export interface FeedbackHandlers {
	apiFeedbacks?: ApiRequestFeedbackHandlers;
	formValidationFeedbacks?: FormValidationFeedbackHandlers;
}
export interface WshopUtilsConfiguration {
	feedbacks?: FeedbackHandlers;
	apiVersion?: string;
}
export default class WshopUtils {
	private _config;
	private readonly _api;
	private readonly _validator;
	private readonly _dsync;
	constructor(config?: WshopUtilsConfiguration);
	setApiFeedbacks(fb: ApiRequestFeedbackHandlers): void;
	setFormValidationFeedbacks(fb: FormValidationFeedbackHandlers): void;
	api(): ApiUtils;
	vd(withAsync?: boolean): Validation;
	md5(str: string): string;
	sha256(str: string): string;
	formDataToObject(formId: string): any;
	base64Encode(str: string): string;
	base64Decode(str: string): string;
	dsync(): Dsync;
	newFormValidation(withAsync?: boolean): Validation;
}

declare module '@wshops/utils'